import { RequiredParam } from "../../types";
import { SmartContract } from "@thirdweb-dev/sdk";
/**
 * Use this to get the contract type for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractType, isLoading, error } = useContractType("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract type of the contract
 * @beta
 */
export declare function useContractType(contractAddress: RequiredParam<string>): import("react-query").UseQueryResult<"split" | "custom" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined, unknown>;
/**
 * Use this to get the publish metadata for a deployed contract.
 *
 * @example
 * ```javascript
 * const { data: publishMetadata, isLoading, error } = useContractPublishMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the published metadata (name, abi, bytecode) of the contract
 * @beta
 */
export declare function useContractPublishMetadata(contractAddress: RequiredParam<string>): import("react-query").UseQueryResult<import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined, unknown>;
/**
 * Use this resolve a contract address to a thirdweb (built-in / custom) contract instance.
 *
 * @example
 * ```javascript
 * const { contract, isLoading, error } = useContract("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract once it is resolved
 * @beta
 */
export declare function useContract(contractAddress: RequiredParam<string>): {
    contract: undefined;
    data: undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: true;
    isRefetchError: false;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: undefined;
    data: undefined;
    error: null;
    isError: false;
    isLoading: true;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: false;
    status: "loading";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: import("@thirdweb-dev/sdk").Split | import("@thirdweb-dev/sdk").NFTDrop | import("@thirdweb-dev/sdk").NFTCollection | import("@thirdweb-dev/sdk").EditionDrop | import("@thirdweb-dev/sdk").Edition | import("@thirdweb-dev/sdk").TokenDrop | import("@thirdweb-dev/sdk").Token | import("@thirdweb-dev/sdk").Vote | import("@thirdweb-dev/sdk").Marketplace | import("@thirdweb-dev/sdk").Pack | SmartContract<any> | undefined;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined;
    error: unknown;
    isError: true;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: true;
    isSuccess: false;
    status: "error";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
} | {
    contract: import("@thirdweb-dev/sdk").Split | import("@thirdweb-dev/sdk").NFTDrop | import("@thirdweb-dev/sdk").NFTCollection | import("@thirdweb-dev/sdk").EditionDrop | import("@thirdweb-dev/sdk").Edition | import("@thirdweb-dev/sdk").TokenDrop | import("@thirdweb-dev/sdk").Token | import("@thirdweb-dev/sdk").Vote | import("@thirdweb-dev/sdk").Marketplace | import("@thirdweb-dev/sdk").Pack | SmartContract<any> | undefined;
    data: {
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined;
    error: null;
    isError: false;
    isLoading: false;
    isLoadingError: false;
    isRefetchError: false;
    isSuccess: true;
    status: "success";
    dataUpdatedAt: number;
    errorUpdatedAt: number;
    failureCount: number;
    isFetched: boolean;
    isFetchedAfterMount: boolean;
    isFetching: boolean;
    isPaused: boolean;
    isPlaceholderData: boolean;
    isPreviousData: boolean;
    isRefetching: boolean;
    isStale: boolean;
    refetch: <TPageData>(options?: (import("react-query").RefetchOptions & import("react-query").RefetchQueryFilters<TPageData>) | undefined) => Promise<import("react-query").QueryObserverResult<{
        contractType: "split" | "nft-drop" | "nft-collection" | "edition-drop" | "edition" | "token-drop" | "token" | "vote" | "marketplace" | "pack" | undefined;
        pubishMetadata: null;
    } | {
        contractType: "custom";
        pubishMetadata: import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").PublishedMetadata | undefined;
    } | undefined, unknown>>;
    remove: () => void;
    fetchStatus: import("react-query").FetchStatus;
};
/**
 * Use this to get the contract metadata for a (built-in or custom) contract.
 *
 * @example
 * ```javascript
 * const { data: contractMetadata, isLoading, error } = useContractMetadata("{{contract_address}}");
 * ```
 *
 * @param contractAddress - the address of the deployed contract
 * @returns a response object that includes the contract metadata of the deployed contract
 * @beta
 */
export declare function useContractMetadata(contractAddress: RequiredParam<string>): import("react-query").UseQueryResult<any, unknown>;
/**
 @internal
 */
export declare function useContractFunctions(contractAddress: RequiredParam<string>): import("react-query").UseQueryResult<import("@thirdweb-dev/sdk/dist/src/schema/contracts/custom").AbiFunction[] | null, unknown>;
